package rip.hippo.mosey.transformer.impl.exploits

import org.objectweb.asm.{Attribute, ByteVector, ClassWriter}
import rip.hippo.mosey.asm.wrapper.ClassWrapper
import rip.hippo.mosey.transformer.Transformer
import rip.hippo.mosey.util.MathUtil
import rip.hippo.mosey.configuration.Configuration


/**
 * @author Hippo
 * @version 1.0.0, 7/31/20
 * @since 1.3.0
 *
 * Inserts trash attributes which will crash asm's class reader but not break bytecode verification.
 */
final class BadAttributeTransformer(configuration: Configuration) extends Transformer {


  private val annotation: Boolean = configuration.get("BadAttribute", "annotation")
  private val code: Boolean = configuration.get("BadAttribute", "code")
  private val module: Boolean = configuration.get("BadAttribute", "module")
  private val nest: Boolean = configuration.get("BadAttribute", "nest")

  override def transform(classWrapper: ClassWrapper): Unit = {
    Option(classWrapper.getAttributes) match {
      case None => classWrapper.createAttributes
      case _ =>
    }

    if (code)
      classWrapper.getAttributes.add(new TrashCodeAttribute)

    if (module)
      classWrapper.getAttributes.add(new TrashModuleAttribute)

    if (nest)
        classWrapper.getAttributes.add(new TrashNestHostAttribute)

    classWrapper.methods.foreach(method => {
      Option(method.getAttributes) match {
        case None => method.createAttributes
        case _ =>
      }
       if (annotation)
         method.getAttributes.add(new TrashAnnotationAttribute)
    })

    classWrapper.fields.foreach(field => {
      Option(field.getAttributes) match {
        case None => field.createAttributes
        case _ =>
      }
       if (code)
         field.getAttributes.add(new TrashCodeAttribute)
      if(annotation)
        field.getAttributes.add(new TrashAnnotationAttribute)
    })
  }

  sealed class TrashAnnotationAttribute extends Attribute("AnnotationDefault") {
    val byteVector: ByteVector = new ByteVector() {
      putByte('F')
      (1 to MathUtil.generate(2, 32)).foreach(_ => putByte(MathUtil.generate(0, 127)))
    }

    override def isUnknown = false
    override def write(classWriter: ClassWriter, code: Array[Byte], codeLength: Int, maxStack: Int, maxLocals: Int): ByteVector = byteVector
  }

  sealed class TrashCodeAttribute extends Attribute("Code") {
    val byteVector: ByteVector = new ByteVector() {
      (1 to MathUtil.generate(2, 32)).foreach(_ => putByte(-MathUtil.generate(0, 127)))
    }

    override def isUnknown = false
    override def write(classWriter: ClassWriter, code: Array[Byte], codeLength: Int, maxStack: Int, maxLocals: Int): ByteVector = byteVector
  }

  sealed class TrashModuleAttribute extends Attribute("Module") {
    val byteVector: ByteVector = new ByteVector() {
      putByte(-1)
      (1 to 32).foreach(_ => putByte(-MathUtil.generate(0, 127)))
    }

    override def isUnknown = false
    override def write(classWriter: ClassWriter, code: Array[Byte], codeLength: Int, maxStack: Int, maxLocals: Int): ByteVector = byteVector
  }

  sealed class TrashNestHostAttribute extends Attribute("NestHost") {
    val byteVector: ByteVector = new ByteVector() {
      putByte(-1)
      (1 to 32).foreach(_ => putByte(-MathUtil.generate(0, 127)))
    }

    override def isUnknown = false
    override def write(classWriter: ClassWriter, code: Array[Byte], codeLength: Int, maxStack: Int, maxLocals: Int): ByteVector = byteVector
  }
}
